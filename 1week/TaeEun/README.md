
# 스터디 PR 백업

## 0203 월 게으름뱅이 왕국 

기본적으로 문제 분석을 제대로 하지 못해 2~3번을 돌아갔다.
문제에 있어서 강사님이 말하신 것처럼
지긋이 분석하고 쓰기 시작하는 것이 좋을 거 같다.

내 생각에 이 문제가 원하는 건
우선순위 큐 구조를 받아들이게 하는 것으로 보인다
합의 최소가 되는 값을 구하기 위해 자연스럽게
순회하면서 정답 리스트의 최댓값보다 작은 값이면 교체를 하는 그런 구조가
필요할 거 같다는 걸 알 수 있다.
나는 정렬 후 pop()을 이용해 최댓값을 다 날려서 약간 회피한 느낌이라
나중에 저런 구조를 배우면 다시 풀어보는 것도 방법인 거 같다.

## 0204 화 삼각형 만들기(미완)

삼각형 만들기 D5 첫 도전을 했는데 만만치 않았다.
처음엔 삼각형 조건을 찾는 탐색을 DFS로 재귀형태로 구현해서
모든 경우의 수를 트리형태를 탐색하는 걸로 생각을 하고 접근을 한 뒤에
그 코딩을 구현하는데 시간을 썼지만
재귀 횟수에 관련된 K 값이 3*10^5만큼 커서 당연히 불가능했다.
그래서 강사님도 잠깐 보고 언급하셨던 '조합론' 에 관한 내용이 필요했다.
여기서 많은 시간을 허비했다.

아직 완벽히 구현하지 못했는데
검색과 GPT를 이용해서 이해한 바로는

a+b+c <= K 형태의 문제는 a+b+c+x = K로 변형이 가능하고
이는 고등학생 시절 봤던 nHr = n+r-1 C r 즉 중복조합의 형태로 쉽게 전체 숫자를 계산해낼 수 있다.
(공과 막대기로 쉽게 이해할 수 있는데 영어로는 Star and bars라고 표현한다.)
그 다음이 삼각형 조건에 해당하지 않는 숫자를 계산해서 전체 숫자에서 빼는 건데
(x+a)+(y+b) < (z+c) 따위의 조건일 때의 불가능한 숫자 조합의 갯수를
코딩으로 닫힌 구조를 통해 구현해내야하는데 시간이 좀 더 필요한 거 같다.

## 0205 수 N-Queen

일단 솔직히 말하자면 아직 완벽히 이해하지 못한 것 같다.
하지만 확실히 뭔가 눈이 뜨인 기분이다.

일단 여기서 묻는 N-Queen 문제는
N × N인 체스판 위에 N개의 퀸을 서로 공격할 수 없게 놓는 문제이다.
인풋으로 N이 주어지면 퀸을 놓는 방법의 수를 출력하는 것이 목적이다.

기본적으로 중요한 아이디어 하나는
퀸의 특성 상 상하 좌우 x자 대각선 전부를 공격하기에
이것을 어떻게 구현하는가?가 첫 번째 스텝이었다

나는 처음에 단순하게 0으로 채워진 N*N 2차원 배열을 만들고
안전하면 한 군데를 두고 그곳을 기준으로 안전하지 않은 곳은 전부 1로 변경하려고 했다.
하지만 너무 무식하게 코딩한다는 느낌이 들어
내 생각이 옳은지 구글과 gpt로 찾아봤다.
여기서 간단하지만 강력한 아이디어를 얻었다.

특정 좌표에서 x,y가 있으면
x+y 값이 같으면 같은 우상좌하 대각선 방향이고
x-y 값이 같으면 같은 좌상우하 대각선 방향이란 점이다

이를 이용하면 x 방향을 하나씩 순회하면서
y 방향 하나, x+y 방향 하나, x-y 방향 하나를 체킹하면서
모든 방향이 안전하면 둔다는 식으로 2차원 배열 없이 코딩이 가능했다.

dfs의 경우 아직 완전히 이해하진 못했지만
간단하게 받아들인 걸 요약해보자면
재귀구조로 특정 방향으로의 탐색을 구현하고 종료조건을 그 방향 끝점으로 둔다.
각 재귀가 돌 때마다 체킹을 하고 끝나면 체킹했던 것을 지우는 구조를 만든다. (백트래킹)
이 부분에 대해선 조금 더 이해가 필요한 것 같다.



## 0206 목 삼각형 만들기 (완)

저번에 도전했다 실패한 삼각형 만들기 문제를 풀었다.

기본적인 아이디어는
경우의 수를 계산하는 공식을 이용해 순회 없이 단순 계산으로 큰 숫자들을 다루는 것이고
닫힌 구조의 공식들, 특히 시그마 형태의 공식들을 이용해
시간복잡도를 확 낮추는 게 핵심이었다.

앞에서 얘기했던 전체 경우의 수를 구하는 것은
단순한 중복조합의 꼴로 정리할 수 있어서 간단하게 표현할 수 있었지만
삼각형 조건에 해당하는 경우의 수 부분은 굉장히 고전했다.

gpt의 힘을 좀 빌려서 수학적으로 정리를 하고 나서야 이해가 좀 됐는데
삼각형 조건에 따른 부등식과 문제에서 주어진 a+b+c<=K 부등식
두 식을 정리하고 나온 인자들을 기준으로 가능한 경우의 수를 더하면
대략 2차식의 시그마 형태가 나오고
이를 x^2의 시그마 x의 시그마 공식들을 이용해 그냥 숫자로 계산해낸다.

이 떄 코딩하면서 생긴 문제로는
오늘 수업시간에서도 말했던 불가능한 부분을 미리 제외하지 않아서 생겼던 오류
경계점에서의 조건을 제대로 확인하지 않아 양수여야할 부분이 음수가 되면서 생겼던 오류
등등이 있었다.


## 0207 금 대면스터디

스위치 바꾸기를 시간 내에 풀려고 하니 할 수 없었다 
했던 문제들도 다시보고 디버깅 능력도 길러야한다.

## 0208 토 격자판의 숫자 이어 붙이기

DFS를 연습하기 아주 좋은 문제인 거 같다.
델타탐색으로 진행 방향을 결정하고, DFS를 문제에 맞게 수정을 살짝 하면 되는 문제로
DFS의 매개변수 부분에서 헷갈리지만 않으면
재귀구조로 구현해낼 수 있다.

## 0209 일 가능한 시험 점수

배점 리스트를 통해 가능한 시험 점수를 전부 체크해서 그 경우의 수를 반환하는 문제였다.

사실 이 문제를 처음 봤을 때는 BFS로 경우의 수를 탐색하면서 들어가면서
혹시 지금까지 합이 같은 경우가 나오는 경우
그 경우의 수 추적은 멈추라는 형태로 구현을 하려고 했다.
하지만 그 와중에 떠오른 아이디어가 있어서 바꿔봤더니 금방 끝났다.

혹시 중복을 제외하는 set() 형태를 이용하면 간단해지지 않을까 한 게 그 아이디어였다.
간단하게 말하자면 숫자 리스트를 돌아가면서 변수를 받는다.
초기값 0이 들어간 ansset를 순회하면서 숫자를 더해서 new set을 만들고
그 newset을 ansset에 합쳐 넣었다.

여기서 조심해야할 점은 set끼리의 연산은 단순히 +가 아니고 합집합의 의미로 |를 써야한다.
그 외에도 리스트 컴프리헨션으로 구현하던 게 set에서도 가능했던 점을 배웠다.
